from collections import namedtuple
import json

import netaddr

from cli.mqtt_client import MQTTClient
from cli.msg import escape, unescape, crc, HDLC_FLAG
from cli.otbox import OTBox
from cli.utils import get_base64_string

class Mote(MQTTClient):
    RESP_TIMEOUT_SECONDS = 5
    PROGRAM_TIMEOUT_SECONDS = 30

    def __init__(self, device_id, config={}):
        super().__init__(config)

        self.device_type = 'mote'
        self.device_id = device_id

    def status(self):
        MoteStatus = namedtuple('MoteStatus',
                                ['device_id', 'firmware', 'up',
                                 'otbox_id', 'location'])
        # first, get status of otboxes
        otbox = OTBox('all')
        otbox_status_list = otbox.status()
        mote_status_list = [(otbox_status['motes'],
                             otbox_id, otbox_status['location'])
                            for otbox_id, otbox_status in otbox_status_list]
        # we need only EUI64, firmware_descriptor, and
        # bootload_success (availability) from mote_status; store them
        # in MoteStatus as well as otbox_id and location
        mote_status_list = [MoteStatus(mote_status['EUI64'],
                                       mote_status['firmware_description'],
                                       mote_status['bootload_success'],
                                       otbox_id,
                                       location)
                            for _list, otbox_id, location in mote_status_list
                            for mote_status in _list]
        if self.device_id == 'all':
            return mote_status_list
        else:
            for mote_status in  mote_status_list:
                if self.device_id == mote_status.device_id:
                    return mote_status
            raise ValueError('mote {0} is not available'.format(self.device_id))

    def disable(self):
        return self._execute('disable')

    def reset(self):
        CMD_RESET = ord('Q').to_bytes(1, 'big')
        return self._send_serialbytes(CMD_RESET)

    def set_dagroot(self):
        CMD_SETDAGROOT = ord('R').to_bytes(1, 'big')
        ACTION_TOGGLE = ord('T').to_bytes(1, 'big')

        prefix = netaddr.IPAddress(self.config['6tisch']['prefix'])
        prefix = int(prefix >> 64).to_bytes(8, 'big')

        # shorthand
        link_layer_key = self.config['6tisch']['link_layer_key']
        index = link_layer_key['index'].to_bytes(1, 'big')
        key = bytes([int(h, 16)
                     for h in link_layer_key['value'].split('-')])

        return self._send_serialbytes(CMD_SETDAGROOT
                                      + ACTION_TOGGLE
                                      + prefix
                                      + index
                                      + key)

    def program(self,
                firmware_name: 'firmware name',
                ihex_file_path: 'path to a firmware file to program (.ihex))'):
        assert firmware_name.endswith('.ihex')
        base64_string = get_base64_string(ihex_file_path)
        # adjust base64 string for json.dumps() and opentestbed:
        # json.dumps() doesn't accept bytes object; needs to convert
        # to string
        base64_string = base64_string.decode('utf-8')
        # remove all new line characters, which opentestbed don't
        # accept
        base64_string = base64_string.replace('\n', '')
        return self._execute('program',
                             {'description': firmware_name,
                              'hex': base64_string},
                             timeout=self.PROGRAM_TIMEOUT_SECONDS)

    def _send_serialbytes(self, msg_body):
        serialbytes = [b for b in (HDLC_FLAG
                                   + escape(msg_body[:] + crc(msg_body))
                                   + HDLC_FLAG)]
        payload = {'serialbytes': serialbytes}
        return self._execute('tomoteserialbytes', payload)
